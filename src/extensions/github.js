var sys = require('util');
var core = require('../core');
var utils = require('../utils').utils;
var https = require('https');
var url = require('url');

var Extension = function(){
    this.identifier = 'github';
};

/**
 * Name identifying this extension
 */
Extension.identifier = "github";

/**
 * IRI identifying the extension
 */
Extension.iri = "http://social-rdf.org/vocab/extensions/github#extension";

/**
 * Version of this extension
 */
Extension.version = "0.0.1";

/**
 * Description of this extension functionality
 */
Extension.description = "Exports public events generated by the user at github and exported throught the events API";

/**
 * Prefix for extension URIs
 */
Extension.prefixes = {'srgh': 'http://social-rdf.org/vocab/extensions/github/'};

/**
 * Service this extension wraps
 */
Extension.service = "http://github.com";

/**
 * List of data objects that will be published by this extension
 */
Extension.dataPublished = [
    core.vocabulary.configuration.makeExportedResource('http://social-rdf.org/vocab/extensions/github/public_updates', 
                                                       'Public Updates', 
                                                       'The public updates published in the configured Github account', 
                                                       core.vocabulary.resources.MicroBlogPost, 
                                                       true)
];

/**
 * Returns an array of JSON-LD objects containing the pieces of configuration data required by this application
 * to run.
 */
Extension.configurationData = function(){
    return [
        core.vocabulary.configuration.makeExtensionConfigurationData("http://rdfs.org/sioc/ns#name", 
                                                                     "Username", 
                                                                     "The name of the user login in the service account", 
                                                                     "string", 
                                                                     true, 
                                                                     ''),

        core.vocabulary.configuration.makeExtensionConfigurationData("http://social-rdf.org/vocab/extensions/github/update_frequency", 
                                                                     "Frequency of update checks (minutes)", 
                                                                     "New data from Github will be retrived with this frequency", 
                                                                     "int", 
                                                                     false,
                                                                     15)
    ];
};


/**
 * Returns an account object generated by this extension when associated to an identity with some configuration data.
 * Returns null if the extension doest not require account creation.
 */
Extension.prototype.installForWebID = function(configuration, webID, callback){
    try {
        var githubUserName = configuration["http://rdfs.org/sioc/ns#name"];
        var updateFrequency = configuration["http://social-rdf.org/vocab/extensions/github/update_frequency"];

        var parsedUrl = url.parse("https://api.github.com/users/"+githubUserName);        
        var options = {host: parsedUrl.host,
                       path: parsedUrl.pathname,
                       port: parsedUrl.port,
                       method: 'GET',
                       headers: {"Accept": "application/json"}};
        
        try {
            var req = https.request(options,function(response){
                if(response.statusCode == 200) {
                    var res = "";
                    
                    response.on('data', function(chunk){
                        res = res+chunk;
                    });
                    response.on('end', function(){
                        var githubAccount = JSON.parse(res);

                        var userAccount = core.vocabulary.configuration.makeUserAccount(webID);
                        core.jsonld.addValue(userAccount, core.vocabulary.sioc.name, githubAccount['login']);
                        core.jsonld.addValue(userAccount, core.vocabulary.foaf.name, githubAccount['name']);
                        core.jsonld.addValue(userAccount, core.vocabulary.sioc.avatar, githubAccount['avatar_url'],'@iri');
                        core.jsonld.addValue(userAccount, core.vocabulary.foaf.based_near, githubAccount['location']);
                        core.jsonld.addValue(userAccount, core.vocabulary.foaf.mbox, githubAccount['email']);
                        core.jsonld.addValue(userAccount, core.vocabulary.dcterms.created, new Date(Date.parse(githubAccount['created'])), 'xsd:date');
                        core.jsonld.addValue(userAccount, core.vocabulary.foaf.homepage, githubAccount['html_url'],'@iri');
                        core.jsonld.addValue(userAccount, core.vocabulary.foaf.accountServiceHomepage, githubAccount['url'],'@iri');
                        userAccount['srgh:update_frequency'] = parseInt(updateFrequency);
                        userAccount['@context']['srgh'] = 'http://social-rdf.org/vocab/extensions/github/';

                        callback(true, userAccount);
                    });
                }
            });
            
            req.on('error', function(error) {
                console.log("[github] ** error: "+error);
                callback(false, e);
            });
            
            req.end();
            
        } catch(e) {
            console.log("[github] ** error: "+error);
            callback(false, e);
        }
    } catch(e) {
        callback(false, e);
    }
};

/**
 * Main loop of the extension
 */
Extension.prototype.execute = function(account, bindings, dbClient){
    try {
        console.log("[github] ** executing extension...");

        var that = this;

        this.webid = account['sioc:has_owner'];
        this.account = account;
        this.bindings = bindings;
        
        var publicBinding = null;

        for(var i=0; i<bindings.length; i++) {
            if(bindings[i]['srcfg:isPublic'] === "true") {
                publicBinding = bindings[i];
            }
        }

        var githubUserName = account['sioc:name'];
        var updateFrequency = parseInt(account["srgh:update_frequency"]);


        var updateFunction = function(){
            try {
                console.log("[github] ** updating github events");

                var parsedUrl = url.parse("https://api.github.com/users/"+githubUserName+"/events/public");
                var options = {host: parsedUrl.host,
                               path: parsedUrl.pathname,
                               port: parsedUrl.port,
                               method: 'GET',
                               headers: {"Accept": "application/json"}};
        

                console.log("REQUEST:");
                console.log(options);
                var req = https.request(options,function (response) {
                                            console.log("RESPONSE:"+response.statusCode);
                                            if(response.statusCode == 200) {
                                                var res = "";

                                                response.on('data', function(chunk){
                                                                res = res+chunk;
                                                            });

                                                response.on('end', function(){
                                                                var data = JSON.parse(res);
                                                                utils.repeat(0, data.length, function(k, env) {
                                                                                 var floop = arguments.callee;
                                                                                 var i = env._i;
                                                                                 lastId = data.id_Str;
                                                                                 var microblogpost = that.makeMicroBlogPost(account, data[i]);
                                                                                 if(microblogpost != null) {
                                                                                     core.jsonld.addValue(microblogpost, core.vocabulary.extensions.bound_to, [publicBinding['@subject']], '@iri');
                                                                                     dbClient.collection('stream', function(coll) {
                                                                                                             //console.log("*** inserted tweet :"+lastId);
                                                                                                             //console.log(microblogpost);
                                                                                                             coll.update({'@subject':microblogpost['@subject']},
                                                                                                                         microblogpost, 
                                                                                                                         {'upsert':true},
                                                                                                                         function(err, res){
                                                                                                                             k(floop, env);
                                                                                                                         });
                                                                                                         });
                                                                                 } else {
                                                                                     k(floop, env);
                                                                                 }
                                                                             },function(){
                                                                                 console.log("[github] ** end of update");
                                                                             });
                                                            });
                                            } else {
                                                console.log("[github] ** (!!!) Exception updating tweet stream");
                                                console.log(e);
                                            }
                                        });

                req.on('error', function(error) {
                           console.log("[github] ** (!!!) Exception updating tweet stream");
                           console.log(e);
                       });
 
                req.end();

            } catch(e) {
                console.log("[github] ** (!!!) Exception updating tweet stream");
                console.log(e);
            }
        };

        // setting up the timer
        setInterval(updateFunction, (updateFrequency*60*1000));
        updateFunction();

    } catch(e) {
        console.log("[github] ** (!!!) exception executing twitter extension");
        console.log(e);
    }

};

Extension.prototype.import = function(account, bindings, dbClient){
    try {
        console.log("[github] ** importing data...");

        var current_page = 1;


        var that = this;

        this.webid = account['sioc:has_owner'];
        this.account = account;
        this.bindings = bindings;
        
        var publicBinding = null;

        for(var i=0; i<bindings.length; i++) {
            if(bindings[i]['srcfg:isPublic'] === "true") {
                publicBinding = bindings[i];
            }
        }

        var githubUserName = account['sioc:name'];
        var updateFrequency = parseInt(account["srgh:update_frequency"]);


        var updateFunction = function(){
            try {
                console.log("[github] ** importing github events");

                var parsedUrl = url.parse("https://api.github.com/users/"+githubUserName+"/events/public");
                var options = {host: parsedUrl.host,
                               path: parsedUrl.pathname+"?page="+current_page+"&per_page=10",
                               port: parsedUrl.port,
                               method: 'GET',
                               headers: {"Accept": "application/json"}};
                current_page++;

                console.log("REQUEST:");
                console.log(options);
                var req = https.request(options,function (response) {
                                            console.log("RESPONSE:"+response.statusCode);
                                            if(response.statusCode == 200) {
                                                var res = "";

                                                response.on('data', function(chunk){
                                                                res = res+chunk;
                                                            });

                                                response.on('end', function(){
                                                                var data = JSON.parse(res);
                                                                utils.repeat(0, data.length, function(k, env) {
                                                                                 var floop = arguments.callee;
                                                                                 var i = env._i;
                                                                                 lastId = data.id_Str;
                                                                                 var microblogpost = that.makeMicroBlogPost(account, data[i]);
                                                                                 if(microblogpost != null) {
                                                                                     console.log("INSERTING");
                                                                                     console.log(microblogpost['@subject']);
                                                                                     core.jsonld.addValue(microblogpost, core.vocabulary.extensions.bound_to, [publicBinding['@subject']], '@iri');
                                                                                     dbClient.collection('stream', function(coll) {
                                                                                                             //console.log("*** inserted tweet :"+lastId);
                                                                                                             //console.log(microblogpost);
                                                                                                             coll.update({'@subject':microblogpost['@subject']},
                                                                                                                         microblogpost, 
                                                                                                                         {'upsert':true},
                                                                                                                         function(err, res){
                                                                                                                             k(floop, env);
                                                                                                                         });
                                                                                                         });
                                                                                 } else {
                                                                                     console.log("SKIPPING");
                                                                                     k(floop, env);
                                                                                 }
                                                                             },function(){
                                                                                 console.log("[github] ** end of update");
                                                                             });
                                                            });
                                            } else {
                                                console.log("[github] ** (!!!) Exception updating tweet stream");
                                                console.log(e);
                                            }
                                        });

                req.on('error', function(error) {
                           console.log("[github] ** (!!!) Exception updating tweet stream");
                           console.log(e);
                       });
 
                req.end();

            } catch(e) {
                console.log("[github] ** (!!!) Exception updating tweet stream");
                console.log(e);
            }
        };

        // setting up the timer
        setInterval(updateFunction, (60*1000));
        updateFunction();

    } catch(e) {
        console.log("[github] ** (!!!) exception executing twitter import");
        console.log(e);
        process.exit(1);
    }
};


Extension.prototype.makeMicroBlogPost = function(account,event) {
    var post = {'@type':[core.vocabulary.sioc.MicroBlogPost,
                         core.vocabulary.sioc.Post],
                '@context': {'xsd':'http://www.w3.org/2001/XMLSchema#'}};

    account = {
        'sioc:name': account['sioc:name'],
        'sioc:avatar': account['sioc:avatar'],
        'sioc:accountOf': this.webid
    };

    post['sioc:has_creator'] = account;

    core.jsonld.addValue(post, core.vocabulary.dcterms.creator, this.webid, '@iri');
    core.jsonld.addValue(post, core.vocabulary.dcterms.created, new Date(Date.parse(event.created_at)), 'xsd:date');  
    // Let's better use a meaningful URL in Github when possible
    core.jsonld.addValue(post, '@subject', ("http://social-rdf.org/vocab/extensions/github/events/ids/"+(new Date(Date.parse(event.created_at)).getTime())+''+(new Date().getTime())), '@iri');
    core.jsonld.addValue(post, core.vocabulary.configuration.managed_by_extension, Extension.iri, '@iri');
    core.jsonld.addValue(post, core.vocabulary.configuration.belongs_to_account, this.account['@subject'], '@iri');

    var repo_html_url;

    switch(event.type) {
    case 'PullRequestEvent':
        repo_html_url = event.repo.url.replace("api.","").replace("repos/","");
        if(event.payload.pull_request.url != null){
            core.jsonld.addValue(post, '@subject', event.payload.pull_request.url, '@iri');            
        } else {
            core.jsonld.addValue(post, '@subject', "http://social-rdf.org/vocab/extensions/github/events/ids/create/pullrequest/"+event.repo.id+"/"+(new Date(Date.parse(event.created_at)).getTime()), '@iri');
        }

        core.jsonld.addValue(post, core.vocabulary.sioc.content, utils.capitalize(event.payload.action)+" <a href='"+event.payload.pull_request.html_url+"'>pull request</a> for repository <a href='"+repo_html_url+"'>"+event.repo.name+"</a>");
        core.jsonld.addValue(post, "srgh:event_type", "http://social-rdf.org/vocab/extensions/github/PullRequestEvent");
        core.jsonld.addValue(post, "srgh:repo_url", event.repo.url,'@iri');
        core.jsonld.addValue(post, "srgh:repo_html_url", repo_html_url, '@iri');
        core.jsonld.addValue(post, "srgh:pull_request_url", event.payload.pull_request.url, '@iri');
        core.jsonld.addValue(post, "srgh:pull_request_html_url", event.payload.pull_request.html_url, '@iri');        
        break;

    case 'CreateEvent':
        repo_html_url = event.repo.url.replace("api.","").replace("repos/",""); 
       if(event.payload.ref_type=='repository') {
            core.jsonld.addValue(post, '@subject', "http://social-rdf.org/vocab/extensions/github/events/ids/create/repo/"+event.repo.id, '@iri');
            core.jsonld.addValue(post, core.vocabulary.sioc.content, "Created <span class='github-ref-type'>repository</span> <a href='"+repo_html_url+"'>"+event.repo.name+"</a>: <span class='github-description'>"+(event.payload.Description||"")+"</span>");            
        } else {
            core.jsonld.addValue(post, '@subject', "http://social-rdf.org/vocab/extensions/github/events/ids/create/"+event.payload.ref_type+"/"+(event.repo.id+event.payload.master_branch||'default')+"/"+event.payload.ref, '@iri');
            core.jsonld.addValue(post, core.vocabulary.sioc.content, "Created <span class='github-ref-type'>"+event.payload.ref_type
                                 +"</span> ref: <span class='github-master-branch'>"+event.payload.ref
                                 +"</span> in repository <a href='"+repo_html_url+"'>"+event.repo.name+"</a>");            
        }
        core.jsonld.addValue(post, "srgh:event_type", "http://social-rdf.org/vocab/extensions/github/CreateEvent");
        core.jsonld.addValue(post, "srgh:repo_url", event.repo.url,'@iri');
        core.jsonld.addValue(post, "srgh:repo_html_url", repo_html_url, '@iri');
        core.jsonld.addValue(post, "srgh:create_event_ref_type", event.payload.ref_type);
        core.jsonld.addValue(post, "srgh:create-_event_ref", event.payload.ref);
        break;

    case 'ForkEvent':
        repo_html_url = event.repo.url.replace("api.","").replace("repos/",""); 
        core.jsonld.addValue(post, '@subject', "http://social-rdf.org/vocab/extensions/github/events/ids/create/fork/"+event.repo.id+"/"+event.payload.forkee.id, '@iri');
        var forkee_repo_html_url = (event.payload.forkee.url||"").replace("api.","").replace("repos/",""); 
        core.jsonld.addValue(post, core.vocabulary.sioc.content, "Forked <a href='"+repo_html_url+"'>"+event.repo.name
                             +"</a> into repository <a href='"+forkee_repo_html_url+"'>"+event.payload.forkee.name+"</a>");            
        
        core.jsonld.addValue(post, "srgh:event_type", "http://social-rdf.org/vocab/extensions/github/ForkEvent");
        core.jsonld.addValue(post, "srgh:repo_url", event.repo.url,'@iri');
        core.jsonld.addValue(post, "srgh:repo_html_url", repo_html_url, '@iri');
        core.jsonld.addValue(post, "srgh:forkee_url", event.payload.forkee.url,'@iri');
        core.jsonld.addValue(post, "srgh:forkee_name", event.payload.forkee.name);
        core.jsonld.addValue(post, "srgh:forkee_html_url", forkee_repo_html_url,'@iri');
        break;

    case 'PushEvent':
        repo_html_url = event.repo.url.replace("api.","").replace("repos/",""); 
        core.jsonld.addValue(post, '@subject', "http://social-rdf.org/vocab/extensions/github/events/ids/create/push/"+event.repo.id+"/"+event.payload.head, '@iri');
        var thisCommit,commit,commits = [];
        event.payload.commits = (event.payload.commits||[]);
        console.log(event.payload.commits.length);
        console.log(event.payload.commits);
        var txt = "Pushed to repo <a href='"+repo_html_url+"'>"+event.repo.name+"</a> commits: <div class='gh-commit-list'><ul>";
        if(event.payload.commits.length == 0) {
            txt = "Pushed to repo <a href='"+repo_html_url+"'>"+event.repo.name+"</a> commits: <div class='gh-commit-list'>";
        }
        for(var i=0; i<event.payload.commits.length; i++) {
            thisCommit = event.payload.commits[i];
            commit = {'@subject':thisCommit.url,
                      '@type': 'http://social-rdf.org/vocab/extensions/github/Commit',
                      'srgh:commit_sha':thisCommit.sha,
                      'dcterms:created': thisCommit.author.date,
                      'srgh:commit_author': thisCommit.author.name,
                      'srgh:commit_message': thisCommit.message,
                      '@context': {'srgh':'http://social-rdf.org/vocab/extensions/github/', 
                                   'dcterms':'http://purl.org/dc/terms/'}};
            commits.push(commit);
            txt = txt + "<li><a href='"+commit['@subject']+"'>"+commit['srgh:commit_message']+"</a> by "+commit['srgh:commit_author']+" ("+commit['srgh:commit_sha']+")</li>";
        }
        if(event.payload.commits.length != 0) {
            txt = txt + "</ul>";
        }        
        txt = txt + "</div>";
        core.jsonld.addValue(post, core.vocabulary.sioc.content, txt);            
        core.jsonld.addValue(post, "srgh:event_type", "http://social-rdf.org/vocab/extensions/github/PushEvent");
        core.jsonld.addValue(post, "srgh:head", event.payload.head);
        core.jsonld.addValue(post, "srgh:repo_url", event.repo.url,'@iri');
        core.jsonld.addValue(post, "srgh:repo_html_url", repo_html_url, '@iri');
        core.jsonld.addValue(post, "srgh:contains_commit", commits);
        break;

    default:
        post=null;
    }


    return post;
};

Extension.prototype.formatNode = function(node, mediaType) {
    if(mediaType == 'rdfa') {        
        switch(node['srgh:event_type']) {
        case "http://social-rdf.org/vocab/extensions/github/PullRequestEvent":
            node['event_type_formatted'] = "pull request";
            break;
        case "http://social-rdf.org/vocab/extensions/github/CreateEvent":
            node['event_type_formatted'] = "create";        
            break;
        case "http://social-rdf.org/vocab/extensions/github/ForkEvent":
            node['event_type_formatted'] = "fork";
            break;
        case "http://social-rdf.org/vocab/extensions/github/PushEvent":
            node['event_type_formatted'] = "push";
            break;
        }
        return node;
    } else {
        return null;
    }
};

Extension.prototype.handleMessage = function(msg) {
    //@todo Ignore by now    
};

// exports
exports.Extension = Extension;
